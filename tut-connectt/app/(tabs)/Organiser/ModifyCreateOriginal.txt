import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import DateTimePicker from '@react-native-community/datetimepicker';
import * as DocumentPicker from 'expo-document-picker';
import { useNavigation, useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";

import {
    Alert,
    FlatList,
    Image,
    Modal,
    Platform,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from "react-native";
import { Calendar } from 'react-native-calendars';
//import { useAdminVenue } from "../../hooks/Admin/useVanue";
// ðŸ‘‡ --- 1. IMPORT THE NEW API FUNCTIONS ---
import AsyncStorage from "@react-native-async-storage/async-storage"; // Import AsyncStorage
import { useLocalSearchParams } from 'expo-router';
import { createEventAPI, updateEventAPI } from '../../data/Organiser/myEvents';
//import { useAdminCalendar } from "../../hooks/Admin/useCalender";
import { useEvents } from '../../hooks/organiser/useMyEvents';
import { useOrganiserCalendar } from "../../hooks/organiser/useOrganiserCalendar";
import { useOrganiserVenue } from "../../hooks/organiser/useOrganiserVenue";
import { useProfileData } from "../../hooks/organiser/useprofileData";
//const { width: screenWidth } = Dimensions.get('window');
// ... (resources, eventTypes, guestTypes, termsText, getMarkedDates, ImageSlider component remain unchanged) ...
const resources = [
    { id: 1, name: "Microphones", image: "https://soundofministry.co.za/wp-content/uploads/2018/10/R21-mic.jpg" },
    { id: 2, name: "Projectors", image: "https://images.unsplash.com/photo-1587825140708-dfaf72ae4b04?auto=format&fit=crop&w=200&q=80" },
    { id: 3, name: "Chairs", image: "https://images.unsplash.com/photo-1506439773649-6e0eb8cfb237?auto=format&fit=crop&w=200&q=80" },
    { id: 4, name: "Tables", image: "https://images.unsplash.com/photo-1533090481720-856c6e3c1fdc?auto=format&fit=crop&w=200&q=80" },
    { id: 5, name: "Speakers", image: "https://images.unsplash.com/photo-1608043152269-423dbba4e7e1?auto=format&fit=crop&w=200&q=80" },
    { id: 6, name: "Whiteboards", image: "https://images.unsplash.com/photo-1611224923853-80b023f02d71?auto=format&fit=crop&w=200&q=80" }
];
const eventTypes = [
    "Official", "Academic related", "Private", "External", "Student"
];
const guestTypes = [
    "VIP", "Media", "Staff", "Student", "Special protocol required"
];
const termsText = `VENUE BOOKING APPLICATION
The institution may grant the APPLICANT permission to use the following in terms of the conditions set out:
â€¢ Facilities for sport are booked through the Sport Division (012) 382-5399/4121
â€¢ Residence facilities are booked through the Residence Division (012) 382-4856
â€¢ Promotional events on campus are booked through Corporate Affairs and Marketing (012) 382-6542
On approval of an application, both parties should complete, sign and date the form.
CONDITIONS:
1. Only someone who has been duly authorised may sign the AA02 form.
2. Cancellations should be made in writing to the Facility Management Office at least five workdays before the relevant function starts.
3. The APPLICANT is responsible for all costs as determined by the institution.
4. The APPLICANT indemnifies the institution against any claims, losses, damages, or liabilities arising from the use of the venue.
5. The APPLICANT must ensure that the venue is left in the same condition as received.
6. No alterations, additions, or modifications may be made to the venue without prior written consent.
7. The institution reserves the right to cancel or reschedule bookings with reasonable notice.
8. All applicable laws, regulations, and institutional policies must be adhered to during the event.
9. The APPLICANT is responsible for obtaining any necessary licenses or permits.
10. Payment terms must be adhered to as specified in the booking agreement.
By accepting these terms, you acknowledge that you have read, understood, and agree to be bound by all conditions set forth in this venue booking application.`;

function getMarkedDates() {
    const marked = {};
    // Class ranges (weekdays only)
    const classRanges = [
        // 2025
        { start: new Date('2025-02-03'), end: new Date('2025-03-28') },
        { start: new Date('2025-04-07'), end: new Date('2025-06-30') },
        { start: new Date('2025-07-14'), end: new Date('2025-09-19') },
        { start: new Date('2025-09-29'), end: new Date('2025-12-05') },
        // 2026
        { start: new Date('2026-02-02'), end: new Date('2026-03-27') },
        { start: new Date('2026-04-07'), end: new Date('2026-06-30') },
        { start: new Date('2026-07-13'), end: new Date('2026-09-18') },
        { start: new Date('2026-09-28'), end: new Date('2026-12-04') },
    ];
    classRanges.forEach(range => {
        let current = new Date(range.start);
        while (current <= range.end) {
            if (current.getDay() !== 0 && current.getDay() !== 6) {
                const dateStr = current.toISOString().split('T')[0];
                marked[dateStr] = { marked: true, dotColor: 'red' };
            }
            current.setDate(current.getDate() + 1);
        }
    });
    // Other can't book ranges (all days)
    const cantBookRanges = [
        // Exams 2025
        { start: new Date('2025-05-26'), end: new Date('2025-06-13') },
        { start: new Date('2025-11-24'), end: new Date('2025-12-05') },
        // Supp exams 2025
        { start: new Date('2025-06-17'), end: new Date('2025-06-30') },
        // Late apps 2025
        { start: new Date('2025-01-20'), end: new Date('2025-01-24') },
        // Reg 2025
        { start: new Date('2025-01-16'), end: new Date('2025-02-02') },
        { start: new Date('2025-07-14'), end: new Date('2025-08-01') },
        // Exit/special 2025
        { start: new Date('2025-01-27'), end: new Date('2025-01-31') },
        { start: new Date('2025-08-03'), end: new Date('2025-08-07') },
        // Closed 2025
        { start: new Date('2025-12-06'), end: new Date('2026-01-05') },
        // Exams 2026
        { start: new Date('2026-05-25'), end: new Date('2026-06-12') },
        { start: new Date('2026-11-23'), end: new Date('2026-12-4') },
        // Supp exams 2026
        { start: new Date('2026-06-17'), end: new Date('2026-06-30') },
        // Late apps 2026
        { start: new Date('2026-01-15'), end: new Date('2026-01-23') },
        // Reg 2026
        { start: new Date('2026-01-15'), end: new Date('2026-02-01') },
        { start: new Date('2026-07-13'), end: new Date('2026-07-31') },
        // Exit/special 2026
        { start: new Date('2026-01-26'), end: new Date('2026-01-30') },
        { start: new Date('2026-08-03'), end: new Date('2026-08-07') },
        // Closed 2026
        { start: new Date('2026-12-05'), end: new Date('2027-01-05') },
    ];
    cantBookRanges.forEach(range => {
        let current = new Date(range.start);
        while (current <= range.end) {
            const dateStr = current.toISOString().split('T')[0];
            marked[dateStr] = { marked: true, dotColor: 'red' };
            current.setDate(current.getDate() + 1);
        }
    });
    // Can book dates (unmark)
    const canBookDates = [
        // Public holidays 2025
        '2025-01-01', '2025-03-21', '2025-04-18', '2025-04-21', '2025-04-27', '2025-04-28',
        '2025-05-01', '2025-06-16', '2025-08-09', '2025-09-24', '2025-12-16', '2025-12-25', '2025-12-26',
        // Public holidays 2026
        '2026-01-01', '2026-03-21', '2026-04-03', '2026-04-06', '2026-04-27', '2026-05-01',
        '2026-06-16', '2026-08-09', '2026-08-10', '2026-09-24', '2026-12-16', '2026-12-25', '2026-12-26',
        // TUT holidays and recesses 2025
        '2025-03-31', '2025-04-01', '2025-04-02', '2025-04-03', '2025-04-04',
        '2025-04-14', '2025-06-15', '2025-09-22', '2025-09-23', '2025-09-24', '2025-09-25', '2025-09-26',
        '2025-12-15',
        // TUT holidays and recesses 2026
        '2026-03-30', '2026-03-31', '2026-04-01', '2026-04-02',
        '2026-06-15', '2026-09-21', '2026-09-22', '2026-09-23', '2026-09-25',
        // Predicate days
        '2025-05-19',
        '2026-05-18', '2026-05-19', '2026-05-20', '2026-05-21', '2026-05-22'
    ];
    canBookDates.forEach(dateStr => {
        if (marked[dateStr]) {
            delete marked[dateStr];
        }
    });
    return marked;
}

// Image Slider Component
const ImageSlider = ({ images = [] }) => {
    const safeImages = images.length > 0 ? images : ["https://via.placeholder.com/300x200?text=No+Image"];
    const [currentIndex, setCurrentIndex] = useState(0);

    const nextImage = () => {
        setCurrentIndex((prevIndex) =>
            prevIndex === safeImages.length - 1 ? 0 : prevIndex + 1
        );
    };
    const prevImage = () => {
        setCurrentIndex((prevIndex) =>
            prevIndex === 0 ? safeImages.length - 1 : prevIndex - 1
        );
    };

    return (
        <View style={styles.sliderContainer}>
            <Image source={{ uri: safeImages[currentIndex] }} style={styles.sliderImage} />
            <TouchableOpacity style={[styles.arrowButton, styles.leftArrow]} onPress={prevImage}>
                <Ionicons name="chevron-back" size={24} color="#fff" />
            </TouchableOpacity>
            <TouchableOpacity style={[styles.arrowButton, styles.rightArrow]} onPress={nextImage}>
                <Ionicons name="chevron-forward" size={24} color="#fff" />
            </TouchableOpacity>
        </View>
    );
};


export default function ModifyCreate() {
    const { venues, reload: reloadVenues } = useOrganiserVenue();
    const [selectedVenue, setSelectedVenue] = useState(null);
    const [viewType, setViewType] = useState("grid");
    const [selectedEventTypes, setSelectedEventTypes] = useState([]);
    const [selectedGuestTypes, setSelectedGuestTypes] = useState([]);
    const [eventName, setEventName] = useState("");
    const [eventType, setEventType] = useState("");
    const [purpose, setPurpose] = useState("");
    const [capacity, setCapacity] = useState("0");
    const [date, setDate] = useState("");
    const [uploadedBanner, setUploadedBanner] = useState(null);
    const [uploadedProof, setUploadedProof] = useState(null);
    const navigation = useNavigation();
    const router = useRouter();
    const [showCalendar, setShowCalendar] = useState(false);
    const [showCampusPicker, setShowCampusPicker] = useState(false);
    const [showStartTimePicker, setShowStartTimePicker] = useState(false);
    const [showEndTimePicker, setShowEndTimePicker] = useState(false);
    const [selectedStartTime, setSelectedStartTime] = useState(new Date());
    const [selectedEndTime, setSelectedEndTime] = useState(new Date());
    const [startTime, setStartTime] = useState("");
    const [endTime, setEndTime] = useState("");
    const [campus, setCampus] = useState("Emalahleni");
    const [termsAccepted, setTermsAccepted] = useState(false);
    const [showTermsModal, setShowTermsModal] = useState(false);
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [tempDate, setTempDate] = useState(new Date());
    const profile = useProfileData();
    const Email = profile?.userInfo?.[0]?.email || "no-email@tut.ac.za"; // fallback
    const { eventId } = useLocalSearchParams();
    const { getEventById } = useEvents();
    const { availableDates, reload: reloadCalendar } = useOrganiserCalendar()
    const currentDate = new Date().toISOString().split('T')[0]; // Today's date
    const [availableDateDetails, setAvailableDateDetails] = useState(null);

    const getCurrentUserId = async () => {
        try {
            const userJson = await AsyncStorage.getItem('user'); // key used at login
            if (userJson) {
                const user = JSON.parse(userJson);
                return user.id; // this must match User.id in your database
            }
            return null;
        } catch (err) {
            console.error('Failed to get current user:', err);
            return null;
        }
    };

    useEffect(() => {
        reloadVenues();
        reloadCalendar();
    }, []);

    useEffect(() => {
        if (venues.length > 0 && selectedVenue === null) {
            setSelectedVenue(venues[0].id);
        }
    }, [venues, selectedVenue]);

    useEffect(() => {
        if (eventId) {
            const eventToEdit = getEventById(eventId);
            if (eventToEdit && venues.length > 0) { // Add check for venues
                setEventName(eventToEdit.title || "");
                setPurpose(eventToEdit.description || "");
                setCapacity((eventToEdit.capacity || "0").replace(' attendees', ''));
                setTermsAccepted(true);
                setDate(eventToEdit.displayDate || "");
                const timeParts = (eventToEdit.time || "").split(' - ');
                if (timeParts.length === 2) {
                    setStartTime(timeParts[0]);
                    setEndTime(timeParts[1]);
                }
                const extractedCampus = extractCampusFromLocation(eventToEdit.location);
                setCampus(extractedCampus);
                const venueMatch = venues.find(v => v.location === eventToEdit.location);
                setSelectedVenue(venueMatch ? venueMatch.id : venues[0].id); // Now safe
                setSelectedEventTypes(eventToEdit.tags || []);
                setSelectedGuestTypes(eventToEdit.guestTypes || []);
                const initialResourceQuantities = resources.reduce((acc, r) => {
                    const existing = (eventToEdit.resources || []).find(res => res.name === r.name);
                    acc[r.id] = existing ? String(existing.quantity) : "0";
                    return acc;
                }, {});
                setResourceQuantities(initialResourceQuantities);
                const initialServices = {
                    Liquor: false,
                    "Kitchen Facilities": false,
                    "Cleaning Services": false,
                    "Extra Security": false,
                    ...eventToEdit.services
                };
                setServices(initialServices);
                if (eventToEdit.bannerUri) {
                    setUploadedBanner({ uri: eventToEdit.bannerUri });
                }
            }
        }
    }, [eventId, getEventById, venues]);

    const extractCampusFromLocation = (location) => {
        const campuses = ["Emalahleni", "Polokwane", "Ga-Rankuwa", "Pretoria", "Soshanguve"];
        // CRITICAL FIX: Ensure 'location' is a string before calling .includes()
        const locationString = String(location || "").toLowerCase();

        if (!locationString) {
            return "Emalahleni"; // Default campus if location is null/undefined
        }

        return campuses.find(campus => locationString.includes(campus.toLowerCase())) || "Emalahleni";
    };

    const [resourceQuantities, setResourceQuantities] = useState(
        resources.reduce((acc, r) => ({ ...acc, [r.id]: "0" }), {})
    );

    const [services, setServices] = useState({
        Liquor: false,
        "Kitchen Facilities": false,
        "Cleaning Services": false,
        "Extra Security": false,
    });

    // ðŸ‘‡ --- 2. ADD THE MISSING resetForm FUNCTION ---
    const resetForm = () => {
        setEventName("");
        setPurpose("");
        setCapacity("0");
        setDate("");
        setStartTime("");
        setEndTime("");
        setCampus("Emalahleni"); // Reset to your default campus
        setSelectedVenue(venues.length > 0 ? venues[0].id : null);
        setSelectedEventTypes([]);
        setSelectedGuestTypes([]);
        setUploadedBanner(null);
        setTermsAccepted(false);

        // Reset resources to all "0"
        setResourceQuantities(
            resources.reduce((acc, r) => ({ ...acc, [r.id]: "0" }), {})
        );

        // Reset services to all false
        setServices({
            Liquor: false,
            "Kitchen Facilities": false,
            "Cleaning Services": false,
            "Extra Security": false,
        });

        // Reset time picker internal state
        setSelectedStartTime(new Date());
        setSelectedEndTime(new Date());

        // Reset view
        setViewType("grid");
    };

    const campusOptions = ["Emalahleni", "Polokwane", "Ga-Rankuwa", "Pretoria", "Soshanguve"];

    const filteredVenues = useMemo(() => {
        const capacityNum = parseInt(capacity) || 0;
        const query = campus.toLowerCase().trim();
        const filtered = venues.filter(venue => {
            const matchesLocation = !query || venue.location.toLowerCase().includes(query);
            const matchesCapacity = capacityNum === 0 || venue.capacity >= capacityNum;
            return matchesLocation && matchesCapacity;
        });
        return filtered;
    }, [campus, capacity, venues]); // Fix: Add 'venues'

    const pickDocument = async (setter) => {
        let result = await DocumentPicker.getDocumentAsync({});
        if (result && result.assets && result.assets.length > 0 && result.assets[0].uri) {
            setter(result.assets[0]);
        }
    };

    // ... (incCapacity, decCapacity, incResource, decResource, onChangeResource, handleDateChange, navigation.setOptions, renderVenueGrid, renderVenueList, markedDates, handleDayPress functions remain unchanged) ...
    const incCapacity = () => setCapacity(c => (parseInt(c) || 0) + 1 + "");
    const decCapacity = () => setCapacity(c => Math.max((parseInt(c) || 0) - 1, 0) + "");
    const incResource = (id) =>
        setResourceQuantities(q => ({ ...q, [id]: String((parseInt(q[id]) || 0) + 1) }));
    const decResource = (id) =>
        setResourceQuantities(q => ({ ...q, [id]: String(Math.max((parseInt(q[id]) || 0) - 1, 0)) }));
    const onChangeResource = (id, val) =>
        setResourceQuantities(q => ({ ...q, [id]: val.replace(/[^0-9]/g, "") }));

    const handleDateChange = (event, selectedDate) => {
        if (Platform.OS === 'android') {
            setShowDatePicker(false);
        }
        if (selectedDate) {
            setTempDate(selectedDate);
            if (event.type === 'set') {
                setDate(selectedDate.toISOString().split('T')[0]);
                if (Platform.OS === 'ios') {
                    setShowDatePicker(false);
                }
            } else if (event.type === 'dismissed' && Platform.OS === 'android') {
                setShowDatePicker(false);
            }
        }
    };

    useEffect(() => {
        navigation.setOptions({ headerShown: false });
    }, []);

    const renderVenueGrid = () => {
        if (filteredVenues.length === 0) {
            return (
                <View style={{ padding: 20, alignItems: "center" }}>
                    <Text style={{ color: "#be1922", fontSize: 16, fontWeight: "600" }}>
                        No venue of such capacity
                    </Text>
                </View>
            );
        }
        return (
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={{ marginVertical: 7, marginLeft: 5 }}>
                {filteredVenues.map(venue => (
                    <TouchableOpacity key={venue.id} style={[styles.venueCard, selectedVenue === venue.id && styles.venueCardSelected]} onPress={() => setSelectedVenue(venue.id)}>
                        <Text style={styles.venueTitle}>{venue.title}</Text>
                        <Text style={styles.venueLocation}><Ionicons name="location-outline" size={15} /> {venue.location}</Text>
                        <Text style={styles.venuePrice}>R{venue.price}</Text>
                        <ImageSlider images={venue.previewImages} />
                        <Text style={styles.venueSubLabel}>Live Availability:</Text>
                        <View style={styles.capacityPill}>
                            <Text style={styles.capacityPillText}>Capacity: {venue.capacity}</Text>
                        </View>
                    </TouchableOpacity>
                ))}
            </ScrollView>
        );
    };

    const renderVenueList = () => {
        if (filteredVenues.length === 0) {
            return (
                <View style={{ padding: 20, alignItems: "center" }}>
                    <Text style={{ color: "#be1922", fontSize: 16, fontWeight: "600" }}>
                        No venue of such capacity
                    </Text>
                </View>
            );
        }
        return (
            <FlatList
                data={filteredVenues}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={{ paddingBottom: 10 }}
                renderItem={({ item }) => (
                    <TouchableOpacity
                        style={[styles.venueListCard, selectedVenue === item.id && styles.venueCardSelected]}
                        onPress={() => setSelectedVenue(item.id)}
                    >
                        <Image source={{ uri: item.image }} style={styles.venueListImage} />
                        <View style={styles.venueListInfo}>
                            <Text style={styles.venueTitle}>{item.title}</Text>
                            <Text style={styles.venueLocation}>
                                <Ionicons name="location-outline" size={14} /> {item.location}
                            </Text>
                            <Text style={styles.venuePrice}>{item.price}</Text>
                            <Text style={styles.venueSubLabel}>Capacity: {item.capacity}</Text>
                        </View>
                    </TouchableOpacity>
                )}
            />
        );
    };

    const markedDates = useMemo(() => {
        const marks = {};
        const venueAvailabilities = {};
        availableDates.forEach((item) => {
            const matchesVenue =
                (Array.isArray(item.venueIds) && item.venueIds.includes(selectedVenue)) ||
                (item.venueId === selectedVenue);
            if (matchesVenue && item.date) {
                marks[item.date] = {
                    marked: true,
                    dotColor: "blue",
                };
                venueAvailabilities[item.date] = item;
            }
        });
        setAvailableDateDetails(venueAvailabilities);
        return marks;
    }, [availableDates, selectedVenue]);

    const handleDayPress = (day) => {
        const selectedDate = day.dateString;
        if (availableDateDetails && availableDateDetails[selectedDate]) {
            const avail = availableDateDetails[selectedDate];
            Alert.alert(
                "Venue Available",
                `Available on ${selectedDate}\nStart: ${avail.startTime}\nEnd: ${avail.endTime}`,
                [{ text: "OK", onPress: () => setDate(selectedDate) }]
            );
        } else {
            Alert.alert("Not Available", "This date is not available for the selected venue.");
        }
    };


    return (
        <ScrollView style={{ backgroundColor: "#fafafc" }} contentContainerStyle={{ paddingBottom: 30 }}>
            {/* ... (All JSX for form fields remains unchanged up to the Submit Button) ... */}
            {/* Event Details (without Date/Time) */}
            <View style={styles.detailsBlock}>
                <Text style={styles.sectionTitle}>Event Details</Text>
                <View style={styles.labelInputGroup}>
                    <Text style={styles.fieldLabel}>Event Name</Text>
                    <TextInput style={styles.input} value={eventName} onChangeText={setEventName} placeholder="Enter event name" />
                </View>
                <View style={styles.labelInputGroup}>
                    <Text style={styles.fieldLabel}>Purpose of the event</Text>
                    <TextInput style={styles.input} value={purpose} onChangeText={setPurpose} placeholder="Enter purpose of the event" />
                </View>
                <View style={styles.labelInputGroup}>
                    <Text style={styles.fieldLabel}>Campus</Text>
                    <TouchableOpacity style={styles.pickerInput} onPress={() => setShowCampusPicker(true)}>
                        <Ionicons name="location-outline" size={20} color="#0077B6" style={{ marginRight: 10 }} />
                        <Text style={campus ? styles.pickerTextSet : styles.pickerTextPlaceholder}>{campus ? campus : "Select campus"}</Text>
                    </TouchableOpacity>
                    <Modal visible={showCampusPicker} transparent={true} animationType="slide">
                        <View style={styles.modalOverlay}>
                            <View style={styles.modalContent}>
                                <Text style={styles.modalTitle}>Select Campus</Text>
                                {campusOptions.map(option => (
                                    <TouchableOpacity key={option} style={styles.modalOption} onPress={() => { setCampus(option); setShowCampusPicker(false); }}>
                                        <Text style={styles.modalOptionText}>{option}</Text>
                                    </TouchableOpacity>
                                ))}
                                <TouchableOpacity style={styles.modalClose} onPress={() => setShowCampusPicker(false)}>
                                    <Text style={styles.modalCloseText}>Cancel</Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </Modal>
                </View>
                <View style={styles.labelInputGroup}>
                    <Text style={styles.fieldLabel}>Capacity</Text>
                    <View style={styles.capacityRow}>
                        <TouchableOpacity style={styles.capBtn} onPress={decCapacity}>
                            <Ionicons name="remove-circle-outline" size={24} color="#0077B6" />
                        </TouchableOpacity>
                        <TextInput style={[styles.input, { width: 60, textAlign: "center", marginRight: 4, marginLeft: 4 }]}
                            value={capacity} onChangeText={v => setCapacity(v.replace(/[^0-9]/g, ""))} placeholder="0" keyboardType="numeric" />
                        <TouchableOpacity style={styles.capBtn} onPress={incCapacity}>
                            <Ionicons name="add-circle-outline" size={24} color="#0077B6" />
                        </TouchableOpacity>
                    </View>
                </View>
                {/* â¬† Date and Time removed from here */}
            </View>

            {/* Venue Selection */}
            <Text style={styles.sectionTitle}>Venue Selection</Text>
            <View style={styles.switchBar}>
                <TouchableOpacity style={[styles.switchButton, viewType === "grid" && styles.switchSelected]} onPress={() => setViewType("grid")}>
                    <Text style={[styles.switchButtonText, viewType === "grid" && styles.switchButtonTextSelected]}>Grid View</Text>
                </TouchableOpacity>
                <TouchableOpacity style={[styles.switchButton, viewType === "list" && styles.switchSelected]} onPress={() => setViewType("list")}>
                    <Text style={[styles.switchButtonText, viewType === "list" && styles.switchButtonTextSelected]}>List View</Text>
                </TouchableOpacity>
            </View>
            {viewType === "grid" ? renderVenueGrid() : renderVenueList()}

            {/* Date and Time â€” MOVED HERE, after Venue Selection */}
            <View style={styles.detailsBlock}>
                <Text style={styles.sectionTitle}>Date & Time</Text>
                <View style={styles.labelInputGroup}>
                    <Text style={styles.fieldLabel}>Date</Text>
                    <TouchableOpacity style={styles.pickerInput} onPress={() => setShowCalendar(true)}>
                        <Ionicons name="calendar-outline" size={20} color="#0077B6" style={{ marginRight: 10 }} />
                        <Text style={date ? styles.pickerTextSet : styles.pickerTextPlaceholder}>{date ? date : "Select date"}</Text>
                    </TouchableOpacity>
                    {showCalendar && (
                        <View style={styles.calendarModal}>
                            {selectedVenue ? (
                                <Calendar
                                    markedDates={markedDates}
                                    minDate={currentDate}
                                    onDayPress={handleDayPress}
                                />
                            ) : (
                                <Text style={{ textAlign: 'center', padding: 20, color: '#888' }}>
                                    Select a venue to view available dates.
                                </Text>
                            )}
                            {selectedVenue && availableDates.length > 0 && (
                                <Text style={{ marginTop: 10, color: 'blue', fontSize: 12 }}>
                                    Note: Only blue dot dates can be booked for the selected venue. Press dot to see availability details.
                                </Text>
                            )}
                            {selectedVenue && availableDates.length > 0 &&
                                !availableDates.some(item =>
                                    (Array.isArray(item.venueIds) && item.venueIds.includes(selectedVenue)) ||
                                    (item.venueId === selectedVenue)
                                ) && (
                                    <Text style={{ marginTop: 10, color: 'orange', fontSize: 14, fontWeight: 'bold', textAlign: 'center' }}>
                                        No available dates for this venue. Please select a different venue or contact admin.
                                    </Text>
                                )
                            }
                            {availableDates.length === 0 && (
                                <Text style={{ marginTop: 10, color: 'red', fontSize: 14, fontWeight: 'bold', textAlign: 'center' }}>
                                    No venue availability data. Please contact admin.
                                </Text>
                            )}
                            <TouchableOpacity style={styles.calendarClose} onPress={() => setShowCalendar(false)}>
                                <Text style={styles.calendarCloseText}>Close</Text>
                            </TouchableOpacity>
                        </View>
                    )}
                </View>
                <View style={styles.labelInputGroup}>
                    <Text style={styles.fieldLabel}>Time</Text>
                    <View style={styles.timeRow}>
                        <View style={styles.timeColumn}>
                            <Text style={styles.timeLabel}>Start Time</Text>
                            <TouchableOpacity style={styles.pickerInput} onPress={() => setShowStartTimePicker(true)}>
                                <Ionicons name="time-outline" size={20} color="#0077B6" style={{ marginRight: 10 }} />
                                <Text style={startTime ? styles.pickerTextSet : styles.pickerTextPlaceholder}>{startTime ? startTime : "Select start time"}</Text>
                            </TouchableOpacity>
                        </View>
                        <View style={styles.timeColumn}>
                            <Text style={styles.timeLabel}>End Time</Text>
                            <TouchableOpacity style={styles.pickerInput} onPress={() => setShowEndTimePicker(true)}>
                                <Ionicons name="time-outline" size={20} color="#0077B6" style={{ marginRight: 10 }} />
                                <Text style={endTime ? styles.pickerTextSet : styles.pickerTextPlaceholder}>{endTime ? endTime : "Select end time"}</Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                    {showStartTimePicker && (
                        <DateTimePicker
                            value={selectedStartTime}
                            mode="time"
                            is24Hour={true}
                            display="default"
                            onChange={(event, selectedDate) => {
                                setShowStartTimePicker(false);
                                if (selectedDate) {
                                    setSelectedStartTime(selectedDate);
                                    const hours = selectedDate.getHours().toString().padStart(2, '0');
                                    const minutes = selectedDate.getMinutes().toString().padStart(2, '0');
                                    setStartTime(`${hours}:${minutes}`);
                                }
                            }}
                        />
                    )}
                    {showEndTimePicker && (
                        <DateTimePicker
                            value={selectedEndTime}
                            mode="time"
                            is24Hour={true}
                            display="default"
                            onChange={(event, selectedDate) => {
                                setShowEndTimePicker(false);
                                if (selectedDate) {
                                    setSelectedEndTime(selectedDate);
                                    const hours = selectedDate.getHours().toString().padStart(2, '0');
                                    const minutes = selectedDate.getMinutes().toString().padStart(2, '0');
                                    setEndTime(`${hours}:${minutes}`);
                                }
                            }}
                        />
                    )}
                </View>
            </View>

            {/* Event Schedule Calendar */}


            {/* Resource Catalogue */}
            <View style={styles.resourceBlock}>
                <Text style={styles.sectionTitle}>Resource Catalogue</Text>
                <View style={styles.resourceGrid}>
                    {resources.map(res => (
                        <View key={res.id} style={styles.resourceItem}>
                            <Image source={{ uri: res.image }} style={styles.resourceIcon} />
                            <Text style={styles.resourceLabel}>{res.name}</Text>
                            <View style={styles.capacityRow}>
                                <TouchableOpacity style={styles.capBtn} onPress={() => decResource(res.id)}>
                                    <Ionicons name="remove-circle-outline" size={21} color="#0077B6" />
                                </TouchableOpacity>
                                <TextInput
                                    style={[styles.input, { width: 48, textAlign: "center", marginRight: 2, marginLeft: 2, paddingVertical: 4, fontSize: 14 }]}
                                    value={resourceQuantities[res.id]}
                                    onChangeText={v => onChangeResource(res.id, v)}
                                    placeholder="0"
                                    keyboardType="numeric"
                                />
                                <TouchableOpacity style={styles.capBtn} onPress={() => incResource(res.id)}>
                                    <Ionicons name="add-circle-outline" size={21} color="#0077B6" />
                                </TouchableOpacity>
                            </View>
                        </View>
                    ))}
                </View>
            </View>

            {/* Services Required */}
            <View style={styles.servicesBlock}>
                <Text style={styles.sectionTitle}>Services Required</Text>
                {Object.keys(services).map(s => (
                    <View key={s} style={styles.serviceRow}>
                        <Text style={styles.serviceLabel}>{s}</Text>
                        <View style={{ flexDirection: "row", gap: 12 }}>
                            <TouchableOpacity
                                style={[styles.yesNoBtn, services[s] && styles.yesNoBtnSelected]}
                                onPress={() => setServices(st => ({ ...st, [s]: true }))}
                            >
                                <Text style={[styles.yesNoText, services[s] && styles.yesNoTextSelected]}>Yes</Text>
                            </TouchableOpacity>
                            <TouchableOpacity
                                style={[styles.yesNoBtn, !services[s] && styles.yesNoBtnSelected]}
                                onPress={() => setServices(st => ({ ...st, [s]: false }))}
                            >
                                <Text style={[styles.yesNoText, !services[s] && styles.yesNoTextSelected]}>No</Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                ))}
            </View>

            {/* Type of function */}
            <View style={styles.typeBlock}>
                <Text style={styles.sectionTitle}>Type of function</Text>
                <View style={styles.checkboxContainer}>
                    {eventTypes.map(type => (
                        <TouchableOpacity key={type} style={styles.checkboxRow} onPress={() => setSelectedEventTypes(prev => prev.includes(type) ? prev.filter(x => x !== type) : [...prev, type])}>
                            <MaterialIcons name={selectedEventTypes.includes(type) ? "check-box" : "check-box-outline-blank"} size={21} color="#0077B6" />
                            <Text style={styles.checkLabel}>{type}</Text>
                        </TouchableOpacity>
                    ))}
                </View>
            </View>

            {/* Type of Guest */}
            <View style={styles.typeBlock}>
                <Text style={styles.sectionTitle}>Type of Guest</Text>
                <View style={styles.checkboxContainer}>
                    {guestTypes.map(type => (
                        <TouchableOpacity key={type} style={styles.checkboxRow} onPress={() => setSelectedGuestTypes(prev => prev.includes(type) ? prev.filter(x => x !== type) : [...prev, type])}>
                            <MaterialIcons name={selectedGuestTypes.includes(type) ? "check-box" : "check-box-outline-blank"} size={21} color="#0077B6" />
                            <Text style={styles.checkLabel}>{type}</Text>
                        </TouchableOpacity>
                    ))}
                </View>
            </View>

            {/* Branding & Mock-up */}
            <View style={styles.mockupBlock}>
                <Text style={styles.sectionTitle}>Branding & Mock-up</Text>
                <TouchableOpacity onPress={() => pickDocument(setUploadedBanner)} style={styles.uploadArea}>
                    <Ionicons name="cloud-upload-outline" size={32} color="#666" style={{ marginBottom: 6 }} />
                    <Text style={styles.uploadText}>Upload Image</Text>
                </TouchableOpacity>
                {uploadedBanner && <Image source={{ uri: uploadedBanner.uri }} style={styles.bannerPreview} />}
                <Text style={styles.mockPreviewLabel}>Banner Mock-up Preview:</Text>
                <View style={styles.bannerBlock}>
                    {uploadedBanner ? <Image source={{ uri: uploadedBanner.uri }} style={styles.bannerImageInPreview} /> : <View style={styles.bannerImageInPreviewGrey} />}
                </View>
            </View>

            {/* Terms and Conditions */}
            <View style={styles.termsBlock}>
                <Text style={styles.sectionTitle}>Terms and Conditions</Text>
                <TouchableOpacity style={styles.checkboxRow} onPress={() => setShowTermsModal(true)}>
                    <MaterialIcons name={termsAccepted ? "check-box" : "check-box-outline-blank"} size={21} color="#0077B6" />
                    <Text style={styles.checkLabel}>I have read and accept the terms and conditions</Text>
                </TouchableOpacity>
                {!termsAccepted && (
                    <Text style={styles.termsError}>You must accept the terms and conditions to proceed with your booking.</Text>
                )}
                <Modal visible={showTermsModal} transparent={true} animationType="slide">
                    <View style={styles.modalOverlay}>
                        <View style={styles.modalContent}>
                            <Text style={styles.modalTitle}>Terms and Conditions</Text>
                            <ScrollView style={styles.termsScroll}>
                                {termsText.split('\n').map((line, index) => (
                                    <Text key={index} style={styles.termsLine}>{line}</Text>
                                ))}
                            </ScrollView>
                            <View style={styles.modalActions}>
                                <TouchableOpacity style={styles.btnAccept} onPress={() => { setTermsAccepted(true); setShowTermsModal(false); }}>
                                    <Text style={styles.btnAcceptText}>Accept</Text>
                                </TouchableOpacity>
                                <TouchableOpacity style={styles.btnDecline} onPress={() => { setTermsAccepted(false); setShowTermsModal(false); }}>
                                    <Text style={styles.btnDeclineText}>Decline</Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </View>
                </Modal>
            </View>

            {/* ðŸ‘‡ --- 3. MODIFIED SUBMIT BUTTON --- ðŸ‘‡ */}
            <TouchableOpacity
                style={[styles.saveButton, !termsAccepted && styles.saveButtonDisabled]}
                disabled={!termsAccepted}
                onPress={async () => {
                    if (!eventName || !purpose || !date || !startTime || !endTime || !termsAccepted || !selectedVenue) {
                        Alert.alert("Error", "Please fill all required fields, select a venue, and accept the terms.");
                        return;
                    }

                    // Check date availability
                    const isDateAvailable = availableDates.some(item => {
                        const matchesVenue =
                            (Array.isArray(item.venueIds) && item.venueIds.includes(selectedVenue)) ||
                            (item.venueId === selectedVenue);
                        return matchesVenue && item.date === date;
                    });

                    if (!isDateAvailable) {
                        Alert.alert(
                            "Invalid Date",
                            "The selected date is not available for this venue. Please choose an available date (blue dot) or select a different venue.",
                            [{ text: "OK" }]
                        );
                        return;
                    }

                    const venue = venues.find(v => v.id === selectedVenue);

                    // Create ISO 8601 strings for the backend
                    const startParts = startTime.split(':');
                    const endParts = endTime.split(':');
                    const eventDateObj = new Date(date);

                    const startDateObj = new Date(eventDateObj);
                    startDateObj.setHours(parseInt(startParts[0]), parseInt(startParts[1]), 0, 0);

                    const endDateObj = new Date(eventDateObj);
                    endDateObj.setHours(parseInt(endParts[0]), parseInt(endParts[1]), 0, 0);

                    // Build the payload that matches event.validation.js
                    const apiPayload = {
                        name: eventName,
                        description: purpose,
                        venueId: selectedVenue,
                        startDateTime: startDateObj.toISOString(),
                        endDateTime: endDateObj.toISOString(),
                        isFree: (venue ? venue.price : "Free") === "Free",
                        // The form does not collect theme, ticketRequired, or ticketDefinitions,
                        // so we omit them (they are optional in your validation)
                    };

                    // Note: The form also collects other data (resources, services, guestTypes)
                    // Your current backend validation doesn't include these fields.
                    // When you add them to your backend, you can add them to this payload.

                    try {
                        if (eventId) {
                            // --- Call new updateEventAPI ---
                            await updateEventAPI(eventId, apiPayload);
                            Alert.alert("Success", "Your event has been updated!", [
                                {
                                    text: "OK",
                                    onPress: () => {
                                        resetForm(); // This will now work
                                        router.push("./Events");
                                    }
                                }
                            ]);
                        } else {
                            // --- Call new createEventAPI ---
                            await createEventAPI(apiPayload);
                            Alert.alert("Success", "Your event has been submitted!", [
                                {
                                    text: "OK",
                                    onPress: () => {
                                        resetForm(); // This will now work
                                        router.push("./Events");
                                    }
                                }
                            ]);
                        }
                    } catch (error) {
                        console.error("Submission error:", error);
                        Alert.alert("Error", `Failed to save your event: ${error.message}`);
                    }
                }}
            >
                <Text style={styles.saveButtonText}>Submit</Text>
            </TouchableOpacity>

        </ScrollView >
    );
}

const styles = StyleSheet.create({
    container2: {
        marginTop: -50,
    },
    container: {
        flex: 1,
        backgroundColor: '#fff',
    },
    center: {
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
    },
    notFoundText: {
        textAlign: 'center',
        fontSize: 18,
        color: '#666',
        marginBottom: 20
    },
    eventImage: {
        width: '100%',
        height: 250,
    },
    backButton: {
        position: 'absolute',
        top: 50,
        left: 20,
        backgroundColor: 'rgba(0,0,0,0.5)',
        borderRadius: 20,
        padding: 8,
        zIndex: 10,
    },
    content: {
        padding: 20,
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
        marginBottom: 20,
    },
    title: {
        fontSize: 24,
        fontWeight: 'bold',
        color: '#191823',
        flex: 1,
        marginRight: 10,
    },
    categoryBadge: {
        backgroundColor: '#EFEFEF',
        paddingHorizontal: 12,
        paddingVertical: 6,
        borderRadius: 16,
    },
    categoryText: {
        fontSize: 12,
        fontWeight: '600',
        color: '#0077B6',
    },
    detailsSection: {
        backgroundColor: '#f8f8f8',
        borderRadius: 12,
        padding: 16,
        marginBottom: 20,
    },
    detailRow: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 12,
    },
    detailText: {
        marginLeft: 12,
        fontSize: 16,
        color: '#333',
        flex: 1,
    },
    section: {
        marginBottom: 24,
    },
    sectionTitle: {
        fontSize: 18,
        fontWeight: 'bold',
        color: '#191823',
        marginBottom: 12,
    },
    description: {
        fontSize: 16,
        lineHeight: 24,
        color: '#666',
    },
    tagsContainer: {
        flexDirection: 'row',
        flexWrap: 'wrap',
    },
    tag: {
        backgroundColor: '#EFEFEF',
        paddingHorizontal: 12,
        paddingVertical: 6,
        borderRadius: 16,
        marginRight: 8,
        marginBottom: 8,
    },
    tagText: {
        fontSize: 14,
        color: '#0077B6',
        fontWeight: '500',
    },
    contactRow: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        backgroundColor: '#f8f8f8',
        borderRadius: 8,
    },
    contactText: {
        marginLeft: 12,
        fontSize: 16,
        color: '#0077B6',
    },
    actionBar: {
        flexDirection: 'row',
        padding: 15,
        backgroundColor: '#fff',
        borderTopWidth: 1,
        borderTopColor: '#eee',
        gap: 12,
        paddingBottom: 20,
        marginBottom: -20
    },
    primaryButton: {
        flex: 2,
        backgroundColor: '#0077B6',
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
    },
    primaryButtonText: {
        color: '#fff',
        fontSize: 16,
        fontWeight: 'bold',
    },
    secondaryButton: {
        flex: 1,
        flexDirection: 'row',

        justifyContent: 'center',
        backgroundColor: '#EFEFEF',
        paddingVertical: 16,
        borderRadius: 12,
        gap: 8,

    },
    secondaryButtonText: {
        color: '#0077B6',
        fontSize: 16,
        fontWeight: '600',
    },
});

